# Задача: Создать менеджер очередей, где задания не ожидали бы ответа от тех кто их выполняет.

- Задачи можно добавить в разные очереди.
- Задачи сортируются по добавлению: добавленные реннее находятся в начале очереди.
- Задача отправленная на обработку удаляется из очереди.
- Задачи могут иметь дополнительные данные

# Архитектура.

- В качестве хранилища используется Redis.
- В качестве сервернного языка NodeJS.
- В качестве клиента [redis](https://www.npmjs.com/package/redis).

Все приложение делится на три части:

1. Основной сервер - получает задачи из внешних приложений, хранит их в хранилище, и отправляет их на обработку в рабочие сервера по запросу.
2. Рабочие сервера - может быть неограниченное количество. Запрашивают задачу из основного сервера и сами решают когда запрашивать следующую.
3. Хранилище данных - Redis.

## Основной сервер:

Методы:

- `constructor(queName, options)` - создает новую очередь с именем `queName` (или подключается к существующей) при создании экземпляра класса. В `options.redis` можно передать параметры подключения к редису.
- `push(params)` - добавить задачу. `params` - хеш объект с данными задачи. Будет сохранен в хранилище как JSON.
- `publish([id])` - публикует задачу добавляя к ней необязательный параметр __id__, по которому эту задачу может идентифицировать рабочий сервер, запросивший задачу.

Кроме этого основной сервер должен постоянно слушать сообщения о свободных серверах и если есть доступные задачи - отдавать их в работу.

## Рабочий сервер:

Методы:

- `constructor(queName, options)` - подключается к очереди `queName`. В `options` можно передать параметры подключения к редису.
- `iAmFree([id], done(error, jobData))` - публикует сообщение для основного сервера, запрашивая новую задачу. Необязательный параметр __id__ позволит идентифицировать задачу.
